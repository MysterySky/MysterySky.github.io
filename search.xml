<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷 P1902 刺杀大使 题解]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%B4%9B%E8%B0%B7-P1902-%E5%88%BA%E6%9D%80%E5%A4%A7%E4%BD%BF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[刺杀大使一道并不难的二分题，竟让我交了上20次，诶，果然还是我太弱了。看完题目就基本想到要怎么做了：只需要对最小伤害代价进行二分即可，check()函数里用搜索判断是否可以到达最后一行，这里的check()用深搜广搜都可以，两种的代码下面都会给出，而经过检验，这道题目用深搜会优于广搜。如果你不像我一般手滑的话，此题基本就可以过了。 然而，导致我反复提交20遍的原因，不是二分答案时卡循环的问题，而是，，， ​ 数组开小了 这也给我提了个醒，不是所有的re都是二分循环的锅，有时候要考虑数组越界的问题。 用汝佳julao的话说，就是 : 编写一个尽量鲁棒的程序！！！ code:深搜做法（更优）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;//Mystery_Sky//#define M 2000#define INF 0x7f7f7f7fconst int dx[] = &#123;0, 0, 1, -1&#125;;const int dy[] = &#123;1, -1, 0, 0&#125;;int l, r, mid;bool vis[M][M], flag;int n, m, a[M][M];void check(int x, int y, int ans)&#123; if(x == n) &#123; flag = true; &#125; for(int i = 0; i &lt;= 3; i++) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &lt;= 0 || yy &lt;= 0 || xx &gt; n || yy &gt; m || a[xx][yy] &gt; ans || vis[xx][yy]) continue; vis[xx][yy] = 1; check(xx, yy, ans); if(flag) return; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[i][j]), r = max(r, a[i][j]); l = 0; while(l &lt;= r) &#123; mid = (l+r)/2; memset(vis, 0, sizeof(vis)); flag = 0; check(1, 1, mid); if(flag) r = mid - 1; else l = mid + 1; &#125; printf("%d\n", l); return 0;&#125; 广搜做法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;//Mystery_Sky//#define M 2000#define INF 0x7f7f7f7fstruct node&#123; int x, y;&#125;;int n, m, p[M][M];int l, r, mid, maxx;int vis[M][M];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int Ans;inline bool check(int ans)&#123; memset(vis, 0, sizeof(vis)); queue &lt;node&gt; q; q.push((node)&#123;1, 1&#125;); while(!q.empty()) &#123; node top = q.front(); q.pop(); int x, y; for(int i = 0; i &lt;= 3; i++) &#123; x = top.x + dx[i]; y = top.y + dy[i]; if(x &lt;= 0 || y &lt;= 0 || x &gt; n || y &gt; m || p[x][y] &gt; ans || vis[x][y]) continue; vis[x][y] = 1; q.push((node)&#123;x, y&#125;); if(x == n) return true; &#125; &#125; return false;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;p[i][j]); l = 0, r = 1024; while(l &lt; r) &#123; mid = (l+r)&gt;&gt;1; if(check(mid)) &#123; r = mid; &#125; else l = mid+1; &#125; printf("%d\n", l); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客完工暨开始正经干活祭]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%8D%9A%E5%AE%A2%E5%AE%8C%E5%B7%A5%E6%9A%A8%E5%BC%80%E5%A7%8B%E6%AD%A3%E7%BB%8F%E5%B9%B2%E6%B4%BB%E7%A5%AD%2F</url>
    <content type="text"><![CDATA[经过两天的不懈努力（又划了两天水），这个blog终于算是完工了！！！由于对博客的美化过于浪费时间（亲身体会），所以我决定停止对博客进行美化了。这也就意味着，现在博客的样子就是它以后的样子了（至少一段时间内不会再改变了）。至于看板娘：什么？看板娘不会说话，不能换装，不能换人？ 嗯，这个也不会再增加那些东西了，我觉得让她安静地待着就好惹（真的不是因为我做不到，不信看这里)。不过还是要立一个flag: 当我成功地将自己想要的live2d做出来之后（估摸着在2020.6.9之后吧）,我将会对看板娘进行一波更新。 接下来的几个月（noip2019之前），我会逐步往博客里添加一些东西，这次可以确定一定会有算法的讲解(学习笔记)了。平时刷题的一些代码我则主要放在了这里。短期的一个小目标： 洛谷试炼场USACO题库。 如果有好的题目，我会将代码同步到这里。 最后，这篇文章没有最后，嗯就这样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo -- My new blog]]></title>
    <url>%2F2019%2F05%2F02%2FHexo-My-new-blog%2F</url>
    <content type="text"><![CDATA[开博祭耗费将近一天的努力（不包括咕咕了的几个星期），看了n篇blog,终于完成了hexo的搭建，真心不容易哇。之前在博客园的博客个人觉得太过臃肿（花里胡哨），所以搭建了hexo的博客（其实就是为了装dalao）我的旧博客，（拍桌子强调）：它没死，我日常的机房题解还会在上面更新，毕竟机房里用hexo不太现实。 flag距离今年的noip也不远了，这个博客将记录我为迎接noip2019所做的一些事情，有题解，也会有一些关于算法的讲解（可能会有），以及一些模板。最后，祝自己：1234567struct node&#123; rp, score;&#125;noip_2019;while(1)&#123; noip_2019.rp++; noip2019.score++;&#125;]]></content>
  </entry>
</search>
