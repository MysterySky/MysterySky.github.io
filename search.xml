<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[月考总结]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%9C%88%E8%80%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[卷首语：再度月考爆炸祭。 语文 98 数学 103 英语 115 物理 60 化学 68 生物 75 总分 519 ​ 乍一看，真心妈耶！！总分比上次低了将近70，一方面是因为上次过于简单加上这次过于困难，另一方面就是这次犯了太多的zz错误。 ​ 下面好好总结一下： 1.语文​ 语文这次比上次略有降低，但降的不多，好像是4分吧。个人感觉不能全怪我，主要是这次的出题人是(毒瘤xms)，前三个选择题都有一个有争议的选项，而我，恰好就完美地命中了这三个争议项（15分钟1分没得的难受不言而喻）。然后漫画作文真心可怕。。。 ​ 考场上愣是看了我10多分钟，愣是没有想出什么正确的立意。最后只能草草写了个关于不能歪曲历史的主题，好像还是拿到了44分。 ​ 一出考场，zzydalao惊呼见过这道作文题，正确立意是关于传统文化！！诶，果然是我太弱了。 2.数学​ 考数学的时候真心感觉大脑去郊游去了，犯了各种各样神奇的错误，让我非常难受啊QAQ!!! 单选12题算完最难算的那部分之后，手欠算了一下1/e,结果脑子一热就选了c，一失足成千古恨啊！！！ ​ 然后填空第一题也是看都不看就写了个40度，还大呼送分题，结果真心送了命 ​ 圆锥曲线的噩梦就不去回忆了，，，细思恐极，不堪入目，10多分钟的计算跪在第一问上了。 3.英语​ 英语虐我千百遍，我待英语如初恋 ​ 阅读D篇真心有毒，上次没看懂错三个，这次看懂了还错三个。。。 ​ 及令人窒息的完型填空，有一种当年的感觉（7个） 4.物理​ 我觉得这次物理不难 ​ 真的不是吹，但现实是这次只要及格了都被xs表扬了，然后就莫名踩线被表扬。 ​ 大部分题目的可做度很高，最难的感觉只有倒数第二题（以及实验题读数？） 5.化学​ 毒瘤lh ​ 拿到卷子看到是他出题，先做好做不完的准备，然后就真没做完（全写完的大题就一道），不仅量多，他居然还直接把高三那边现在的模考题抽过来考，有点过分了。 ​ 不过分虽然不高，但排名还是比较前的，毕竟高分的不多。（六班某神仙震惊了所有人，在二楼其他班最高分都只有80出头的情况下拿了96分的神仙成绩，%%%） 6.生物​ 冲击90未果然后惨得75，很难受，这里不愿多说，是我自己的问题 总结：这次手滑过于严重，有意外也有自己的原因（前段时间有点混），接下来我要开始认真刷题了。立两个flag: 1.下次我要回第一考场去！！！2.生物90！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1126 机器人搬重物]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%B4%9B%E8%B0%B7P1126-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9%2F</url>
    <content type="text"><![CDATA[机器人搬重物咕咕咕了几个星期，终于静下心来写完了这篇题解 这道题的坑点还是比较多的，下面会一一列举。 先审题：​ 根据题目的意思，这是一道走迷宫的问题，显然用bfs去求解。 ​ 首先，我们需要建一张图。。。 ​ 这里很多人下意识地将题目中输入的图存下，这就涉及到了此题的第一个坑点了： 坑点1：应建立n+1 * m+1 大小的图​ 不理解？不讲道理？ ​ 这里我们要重新回到题目中，题目的描述为：机器人的形状是一个直径$1.6米的球，而机器人走的是格点，而障碍物存在于格子上，这就意味着每一个有障碍物存在的格子的四个端点都是不能够通行的，而我们操作的是机器人，所以对于一张nm的格子图自然需要建一张（n+1） （m+1）的格点图 。 建图： 123456789for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a); if(a == 1) &#123; vis[i][j] = vis[i][j+1] = vis[i+1][j] = vis[i+1][j+1] = 1; map[i][j] = map[i][j+1] = map[i+1][j] = map[i+1][j+1] = 1; &#125; &#125;n++, m++; 这里的vis数组用于后面bfs中判断是否到过，而当该点本身无法到达时，直接置为1。 而这里的map数组只是单纯用于存这个点周围是否有障碍物，具体用处后面会提到。 ​ 如果你以为这就结束了，那么就大错特错了，还要再加两行: 12for(int i = 1; i &lt;= m; i++) vis[1][i] = vis[n][i] = 1;for(int i = 1; i &lt;= n; i++) vis[i][1] = vis[i][m] = 1; What? Why? ​ 仔细想想，以机器人的体积，它是无法走到第一行（第一列）的格点以及最后一行（最后一列）的格点上去的（旁边是墙！！！） 坑点2：四周的边界走不了再审题​ 题中增加了方向的问题，以及机器人每次能走1~3步。 ​ 对于方向，我们可以考虑在bfs用到的结构体中增加方向的值，即使用dirt来表示该时刻机器人的方向。 结构体 1234struct node&#123; int x, y, step, dirt, turn;//dirt取值为1， 2， 3， 4时别表示东，西，南，北。 node (int xx, int yy, int ss, int dd, int tt) : x(xx), y(yy), step(ss), dirt(dd), turn(tt)&#123;&#125;&#125;; ​ 接下来就是主要的bfs函数了。 1234567891011121314inline void bfs(int x1, int y1, int x2, int y2, char to)&#123; int drt; if(to == 'E') drt = 1; else if(to == 'W') drt = 2; else if(to == 'S') drt = 3; else drt = 4; q.push(node(x1, y1, 0, drt, 0)); while(!q.empty()) &#123; node top = q.front(); q.pop(); int dx, dy; 、、、 &#125; 以上部分与正常的bfs打法无异，只是单纯的多了一个预处理方向的过程，to就是最初的方向。 接着我们考虑用for循环来实现行走与转向的问题。 1.正常的行走（i = 1、2、3时） 12345678910111213141516171819202122232425262728293031323334for(int i = 1; i &lt;= 5; i++) &#123;//i=4表示左转， i=5表示右转 if(i != 4 &amp;&amp; i != 5) &#123; drt = top.dirt; if(drt == 1) &#123; dx = top.x; dy = top.y + i; &#125; else if(drt == 2) &#123; dx = top.x; dy = top.y - i; &#125; else if(drt == 3) &#123; dx = top.x + i; dy = top.y; &#125; else &#123; dx = top.x - i; dy = top.y; &#125; if(dx &lt;= 0 || dy &lt;= 0 || dx &gt; n || dy &gt; m) &#123; i = 3;//如果走了该步数已经超出了边界,那么该步数以后的步数必然会超过边界，这样直接跳到转向部分即可。 continue; &#125; if(vis[dx][dy]) &#123; continue; &#125; if(dx == x2 &amp;&amp; dy == y2) &#123; dis[x2][y2] = top.step + 1; //到达终点，存值，返回。 return; &#125; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step+1, drt, 0)); &#125; 这里引入的dis数组存的是到达某点的最短时间。 2.转向（i = 4、5时） 1234567891011121314151617181920212223else if(i == 4)&#123; dx = top.x, dy = top.y; drt = top.dirt; if(drt == 1) drt = 4; else if(drt == 2) drt = 3; else if(drt == 3) drt = 1; else drt = 2; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step + 1, drt, t+1)); &#125; else &#123; dx = top.x, dy = top.y; drt = top.dirt; if(drt == 1) drt = 3; else if(drt == 2) drt = 4; else if(drt == 3) drt = 2; else drt = 1; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step + 1, drt, t+1)); &#125; &#125; 这里左转右转时的方向要注意，别把自己弄晕了！ 然后写好主函数，我们就可以愉快地 ac了 ！诶，WA?为什么？？ 输入坐标的时候加上这个试试 1234scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2);getchar();x1++, x2++, y1++, y2++;scanf("%c", &amp;to); ​ 这样做的原因看完样例相信聪明的你就明白了。 然后，再提交？怎么又错了几个点啊！！ 坑点3：终点可能在无法到达的格点上坑点4: 起点和终点可能是同一个点​ 对于上述的两个坑点，只需要两个if特判就可以了 12if(vis[x1][y1] || vis[x2][y2]) return 0 * printf("-1\n");if(x1 == x2 &amp;&amp; y1 == y2) return 0 * printf("0\n"); 这样做了之后好像还是ac不了诶。 ​ 这里我们回头看看bfs里的for循环，其中有两个问题我们需要解决一下： ​ q1:对于同一个点，for循环中的i = 4、5可能会使机器人一直在该点转向。 ​ q2:有没有想过这样一个问题，如果机器人在往前走一步的时候遇到了障碍物，那么它前面的两个点vis都为1，但当它往前走三步时，该个点的vis = 0，即机器人直接穿过了障碍物到达了障碍物后面的点，这显然是不符合实际的。 ​ 对于q1，我们就需要用到node结构体里定义的turn作为一个转向次数计数器去判断，当机器人在某个点转向3次即以上时，直接跳过。 ​ 对于q2，我们就需要用到之前定义的map数组去判断了。 考虑完了上述的所有坑点后，这道题终于成功的AC了（什么？起始转向次数有设置坑点？不管了，反正我没有遇到） code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;//Mystery_Sky//#define INF 0x3f3f3f3fconst int M = 100;struct node&#123; int x, y, step, dirt, turn;//dirt取值为1， 2， 3， 4时别表示东，西，南，北。 node (int xx, int yy, int ss, int dd, int tt) : x(xx), y(yy), step(ss), dirt(dd), turn(tt)&#123;&#125;&#125;;queue &lt;node&gt; q;int n, m, ans, x1, x2, y1, y2;char to;int dis[M][M], map[M][M];bool vis[M][M];inline void bfs(int x1, int y1, int x2, int y2, char to)&#123; int drt; if(to == 'E') drt = 1; else if(to == 'W') drt = 2; else if(to == 'S') drt = 3; else drt = 4; q.push(node(x1, y1, 0, drt, 0)); while(!q.empty()) &#123; node top = q.front(); q.pop(); int dx, dy; for(int i = 1; i &lt;= 5; i++) &#123;//i=4表示左转， i=5表示右转 if(i != 4 &amp;&amp; i != 5) &#123; drt = top.dirt; if(drt == 1) &#123; dx = top.x; dy = top.y + i; &#125; else if(drt == 2) &#123; dx = top.x; dy = top.y - i; &#125; else if(drt == 3) &#123; dx = top.x + i; dy = top.y; &#125; else &#123; dx = top.x - i; dy = top.y; &#125; if(map[dx][dy] == 1) i = 3; if(dx &lt;= 0 || dy &lt;= 0 || dx &gt; n || dy &gt; m) &#123; i = 3; continue; &#125; if(vis[dx][dy]) &#123; continue; &#125; if(dx == x2 &amp;&amp; dy == y2) &#123; dis[x2][y2] = top.step + 1; return; &#125; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step+1, drt, 0)); &#125; else if(i == 4)&#123; int t = top.turn; if(t &gt; 2) continue; dx = top.x, dy = top.y; drt = top.dirt; if(drt == 1) drt = 4; else if(drt == 2) drt = 3; else if(drt == 3) drt = 1; else drt = 2; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step + 1, drt, t+1)); &#125; else &#123; int t = top.turn; if(t &gt; 2) continue; dx = top.x, dy = top.y; drt = top.dirt; if(drt == 1) drt = 3; else if(drt == 2) drt = 4; else if(drt == 3) drt = 2; else drt = 1; dis[dx][dy] = min(top.step + 1, dis[dx][dy]); vis[dx][dy] = 1; q.push(node(dx, dy, top.step + 1, drt, t+1)); &#125; &#125; &#125; return;&#125;int main() &#123; int a; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a); if(a == 1) &#123; vis[i][j] = vis[i][j+1] = vis[i+1][j] = vis[i+1][j+1] = 1; map[i][j] = map[i][j+1] = map[i+1][j] = map[i+1][j+1] = 1; &#125; &#125; n++, m++; for(int i = 1; i &lt;= m; i++) vis[1][i] = vis[n][i] = 1; for(int i = 1; i &lt;= n; i++) vis[i][1] = vis[i][m] = 1; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); getchar(); x1++, x2++, y1++, y2++; scanf("%c", &amp;to); memset(dis, INF, sizeof(dis)); if(vis[x1][y1] || vis[x2][y2]) return 0 * printf("-1\n"); if(x1 == x2 &amp;&amp; y1 == y2) return 0 * printf("0\n"); bfs(x1, y1, x2, y2, to); if(dis[x2][y2] == INF) printf("-1\n"); else printf("%d\n", dis[x2][y2]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1902 刺杀大使 题解]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%B4%9B%E8%B0%B7-P1902-%E5%88%BA%E6%9D%80%E5%A4%A7%E4%BD%BF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[刺杀大使一道并不难的二分题，竟让我交了上20次，诶，果然还是我太弱了。看完题目就基本想到要怎么做了：只需要对最小伤害代价进行二分即可，check()函数里用搜索判断是否可以到达最后一行，这里的check()用深搜广搜都可以，两种的代码下面都会给出，而经过检验，这道题目用深搜会优于广搜。如果你不像我一般手滑的话，此题基本就可以过了。 然而，导致我反复提交20遍的原因，不是二分答案时卡循环的问题，而是，，， ​ 数组开小了 这也给我提了个醒，不是所有的re都是二分循环的锅，有时候要考虑数组越界的问题。 用汝佳julao的话说，就是 : 编写一个尽量鲁棒的程序！！！ code:深搜做法（更优）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;//Mystery_Sky//#define M 2000#define INF 0x7f7f7f7fconst int dx[] = &#123;0, 0, 1, -1&#125;;const int dy[] = &#123;1, -1, 0, 0&#125;;int l, r, mid;bool vis[M][M], flag;int n, m, a[M][M];void check(int x, int y, int ans)&#123; if(x == n) &#123; flag = true; &#125; for(int i = 0; i &lt;= 3; i++) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &lt;= 0 || yy &lt;= 0 || xx &gt; n || yy &gt; m || a[xx][yy] &gt; ans || vis[xx][yy]) continue; vis[xx][yy] = 1; check(xx, yy, ans); if(flag) return; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[i][j]), r = max(r, a[i][j]); l = 0; while(l &lt;= r) &#123; mid = (l+r)/2; memset(vis, 0, sizeof(vis)); flag = 0; check(1, 1, mid); if(flag) r = mid - 1; else l = mid + 1; &#125; printf("%d\n", l); return 0;&#125; 广搜做法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;//Mystery_Sky//#define M 2000#define INF 0x7f7f7f7fstruct node&#123; int x, y;&#125;;int n, m, p[M][M];int l, r, mid, maxx;int vis[M][M];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int Ans;inline bool check(int ans)&#123; memset(vis, 0, sizeof(vis)); queue &lt;node&gt; q; q.push((node)&#123;1, 1&#125;); while(!q.empty()) &#123; node top = q.front(); q.pop(); int x, y; for(int i = 0; i &lt;= 3; i++) &#123; x = top.x + dx[i]; y = top.y + dy[i]; if(x &lt;= 0 || y &lt;= 0 || x &gt; n || y &gt; m || p[x][y] &gt; ans || vis[x][y]) continue; vis[x][y] = 1; q.push((node)&#123;x, y&#125;); if(x == n) return true; &#125; &#125; return false;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;p[i][j]); l = 0, r = 1024; while(l &lt; r) &#123; mid = (l+r)&gt;&gt;1; if(check(mid)) &#123; r = mid; &#125; else l = mid+1; &#125; printf("%d\n", l); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客完工暨开始正经干活祭]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%8D%9A%E5%AE%A2%E5%AE%8C%E5%B7%A5%E6%9A%A8%E5%BC%80%E5%A7%8B%E6%AD%A3%E7%BB%8F%E5%B9%B2%E6%B4%BB%E7%A5%AD%2F</url>
    <content type="text"><![CDATA[经过两天的不懈努力（又划了两天水），这个blog终于算是完工了！！！由于对博客的美化过于浪费时间（亲身体会），所以我决定停止对博客进行美化了。这也就意味着，现在博客的样子就是它以后的样子了（至少一段时间内不会再改变了）。至于看板娘：什么？看板娘不会说话，不能换装，不能换人？ 嗯，这个也不会再增加那些东西了，我觉得让她安静地待着就好惹（真的不是因为我做不到，不信看这里)。不过还是要立一个flag: 当我成功地将自己想要的live2d做出来之后（估摸着在2020.6.9之后吧）,我将会对看板娘进行一波更新。 接下来的几个月（noip2019之前），我会逐步往博客里添加一些东西，这次可以确定一定会有算法的讲解(学习笔记)了。平时刷题的一些代码我则主要放在了这里。短期的一个小目标： 洛谷试炼场USACO题库。 如果有好的题目，我会将代码同步到这里。 最后，这篇文章没有最后，嗯就这样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo -- My new blog]]></title>
    <url>%2F2019%2F05%2F02%2FHexo-My-new-blog%2F</url>
    <content type="text"><![CDATA[开博祭耗费将近一天的努力（不包括咕咕了的几个星期），看了n篇blog,终于完成了hexo的搭建，真心不容易哇。之前在博客园的博客个人觉得太过臃肿（花里胡哨），所以搭建了hexo的博客（其实就是为了装dalao）我的旧博客，（拍桌子强调）：它没死，我日常的机房题解还会在上面更新，毕竟机房里用hexo不太现实。 flag距离今年的noip也不远了，这个博客将记录我为迎接noip2019所做的一些事情，有题解，也会有一些关于算法的讲解（可能会有），以及一些模板。最后，祝自己：1234567struct node&#123; rp, score;&#125;noip_2019;while(1)&#123; noip_2019.rp++; noip2019.score++;&#125;]]></content>
  </entry>
</search>
